<!--
Codes with #...InsertLocation# in them are used within by the automatic bundler script to locate places for code insertion

Please refer to the github repo for a non-bundled version of the html, css, js, and logo files.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0MTAiIGhlaWdodD0iNDA1IiB2aWV3Qm94PSItMC41IC0wLjUgNDEwIDQwNSIgY29udGVudD0iJmx0O214ZmlsZSBob3N0PSZxdW90O0VsZWN0cm9uJnF1b3Q7IG1vZGlmaWVkPSZxdW90OzIwMjQtMDMtMjdUMTU6MzA6MzEuMTgxWiZxdW90OyBhZ2VudD0mcXVvdDtNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNV83KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBkcmF3LmlvLzIyLjAuMyBDaHJvbWUvMTE0LjAuNTczNS4yODkgRWxlY3Ryb24vMjUuOC40IFNhZmFyaS81MzcuMzYmcXVvdDsgZXRhZz0mcXVvdDtCanFfX3lWQmoydC1NZzB3bFN2SSZxdW90OyB2ZXJzaW9uPSZxdW90OzIyLjAuMyZxdW90OyB0eXBlPSZxdW90O2RldmljZSZxdW90OyZndDsmIzEwOyAgJmx0O2RpYWdyYW0gbmFtZT0mcXVvdDtQYWdlLTEmcXVvdDsgaWQ9JnF1b3Q7X1pHcFRXOFhCNWRoY1pmUThQYTUmcXVvdDsmZ3Q7JiMxMDsgICAgJmx0O214R3JhcGhNb2RlbCBkeD0mcXVvdDsxMDE2LjQmcXVvdDsgZHk9JnF1b3Q7NzMzLjQmcXVvdDsgZ3JpZD0mcXVvdDsxJnF1b3Q7IGdyaWRTaXplPSZxdW90OzEwJnF1b3Q7IGd1aWRlcz0mcXVvdDswJnF1b3Q7IHRvb2x0aXBzPSZxdW90OzEmcXVvdDsgY29ubmVjdD0mcXVvdDsxJnF1b3Q7IGFycm93cz0mcXVvdDsxJnF1b3Q7IGZvbGQ9JnF1b3Q7MSZxdW90OyBwYWdlPSZxdW90OzEmcXVvdDsgcGFnZVNjYWxlPSZxdW90OzAuMTImcXVvdDsgcGFnZVdpZHRoPSZxdW90OzQwJnF1b3Q7IHBhZ2VIZWlnaHQ9JnF1b3Q7NDAmcXVvdDsgYmFja2dyb3VuZD0mcXVvdDtub25lJnF1b3Q7IG1hdGg9JnF1b3Q7MCZxdW90OyBzaGFkb3c9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICZsdDtyb290Jmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90OzAmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDsxJnF1b3Q7IHBhcmVudD0mcXVvdDswJnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7R3libkh0cXE0QUNlbi0xdnFMYVktMSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9NTtmaWxsQ29sb3I9I2UxZDVlNztzdHJva2VDb2xvcj0jRkYzMzk5O29wYWNpdHk9NTA7c2hhZG93PTA7bGFiZWxCb3JkZXJDb2xvcj1ub25lOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzI3NyZxdW90OyB5PSZxdW90OzI3OSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNzUmcXVvdDsgeT0mcXVvdDs4OSZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDszMTAmcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yOSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9NTtmaWxsQ29sb3I9I2UxZDVlNztzdHJva2VDb2xvcj0jRkYzMzk5O29wYWNpdHk9NTA7c2hhZG93PTA7bGFiZWxCb3JkZXJDb2xvcj1ub25lOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzI3MCZxdW90OyB5PSZxdW90OzI4NCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyMDImcXVvdDsgeT0mcXVvdDs0OCZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDszMzAmcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yOCZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9MTA7ZmlsbENvbG9yPSNlMWQ1ZTc7c3Ryb2tlQ29sb3I9I0ZGMzM5OTtvcGFjaXR5PTUwO3NoYWRvdz0wO2xhYmVsQm9yZGVyQ29sb3I9bm9uZTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyODAmcXVvdDsgeT0mcXVvdDsyNjQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MTA5JnF1b3Q7IHk9JnF1b3Q7NDcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtBcnJheSBhcz0mcXVvdDtwb2ludHMmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MTEwJnF1b3Q7IHk9JnF1b3Q7MTU0JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7L0FycmF5Jmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMjcmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO2N1cnZlZD0xO3N0cm9rZVdpZHRoPTMwO2ZpbGxDb2xvcj0jZTFkNWU3O3N0cm9rZUNvbG9yPSNGRjMzOTk7b3BhY2l0eT01MDtzaGFkb3c9MDtsYWJlbEJvcmRlckNvbG9yPW5vbmU7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjYwJnF1b3Q7IHk9JnF1b3Q7Mjc0JnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzE3OSZxdW90OyB5PSZxdW90OzEwNiZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNTImcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yNiZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9MjA7ZmlsbENvbG9yPSNlMWQ1ZTc7c3Ryb2tlQ29sb3I9I0ZGMzM5OTtvcGFjaXR5PTUwO3NoYWRvdz0wO2xhYmVsQm9yZGVyQ29sb3I9bm9uZTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNzgmcXVvdDsgeT0mcXVvdDsyNzQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7NTEmcXVvdDsgeT0mcXVvdDsxMjQmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtBcnJheSBhcz0mcXVvdDtwb2ludHMmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjA4JnF1b3Q7IHk9JnF1b3Q7MTc0JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7L0FycmF5Jmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMjMmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO2N1cnZlZD0xO3N0cm9rZVdpZHRoPTQwO2ZpbGxDb2xvcj0jZTFkNWU3O3N0cm9rZUNvbG9yPSNGRjMzOTk7b3BhY2l0eT01MDtzaGFkb3c9MDtsYWJlbEJvcmRlckNvbG9yPW5vbmU7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjgwJnF1b3Q7IHk9JnF1b3Q7Mjc0JnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzUwJnF1b3Q7IHk9JnF1b3Q7MjA0JnF1b3Q7IGFzPSZxdW90O3RhcmdldFBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7QXJyYXkgYXM9JnF1b3Q7cG9pbnRzJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzE1MCZxdW90OyB5PSZxdW90OzE3NCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0Oy9BcnJheSZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTEmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsxNTMmcXVvdDsgeT0mcXVvdDsxNDkmcXVvdDsgd2lkdGg9JnF1b3Q7MjU4JnF1b3Q7IGhlaWdodD0mcXVvdDsyNTgmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMiZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FzcGVjdD1maXhlZDtmaWxsQ29sb3I9I0ZGMzM5OTtzdHJva2VXaWR0aD0yO2dyYWRpZW50Q29sb3I9I0ZGNjlBRjtncmFkaWVudERpcmVjdGlvbj1lYXN0O3NoYWRvdz0xOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyB2ZXJ0ZXg9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB4PSZxdW90OzIwJnF1b3Q7IHk9JnF1b3Q7MTY0JnF1b3Q7IHdpZHRoPSZxdW90OzgwJnF1b3Q7IGhlaWdodD0mcXVvdDs4MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy00JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbGxpcHNlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YXNwZWN0PWZpeGVkO2ZpbGxDb2xvcj0jRkYzMzk5O3N0cm9rZVdpZHRoPTI7Z3JhZGllbnRDb2xvcj0jRkY2OUFGO2dyYWRpZW50RGlyZWN0aW9uPWVhc3Q7c2hhZG93PTE7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IHZlcnRleD0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHg9JnF1b3Q7MTgwJnF1b3Q7IHk9JnF1b3Q7MjQmcXVvdDsgd2lkdGg9JnF1b3Q7NDAmcXVvdDsgaGVpZ2h0PSZxdW90OzQwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTkmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsyMCZxdW90OyB5PSZxdW90Ozk0JnF1b3Q7IHdpZHRoPSZxdW90OzYwJnF1b3Q7IGhlaWdodD0mcXVvdDs2MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0xMCZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FzcGVjdD1maXhlZDtmaWxsQ29sb3I9I0ZGMzM5OTtzdHJva2VXaWR0aD0yO2dyYWRpZW50Q29sb3I9I0ZGNjlBRjtncmFkaWVudERpcmVjdGlvbj1lYXN0O3NoYWRvdz0xOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyB2ZXJ0ZXg9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB4PSZxdW90OzgwJnF1b3Q7IHk9JnF1b3Q7MTQmcXVvdDsgd2lkdGg9JnF1b3Q7NjAmcXVvdDsgaGVpZ2h0PSZxdW90OzYwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTExJnF1b3Q7IHZhbHVlPSZxdW90OyZhbXA7bHQ7Zm9udCBzdHlsZT0mYW1wO3F1b3Q7Zm9udC1zaXplOiAxMDBweDsmYW1wO3F1b3Q7IGZhY2U9JmFtcDtxdW90O2ltcGFjdCZhbXA7cXVvdDsmYW1wO2d0O21zIEZlYVNUJmFtcDtsdDsvZm9udCZhbXA7Z3Q7JnF1b3Q7IHN0eWxlPSZxdW90O3RleHQ7aHRtbD0xO3N0cm9rZUNvbG9yPW5vbmU7ZmlsbENvbG9yPW5vbmU7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3doaXRlU3BhY2U9d3JhcDtyb3VuZGVkPTA7bW92YWJsZT0xO3Jlc2l6YWJsZT0xO3JvdGF0YWJsZT0xO2RlbGV0YWJsZT0xO2VkaXRhYmxlPTE7bG9ja2VkPTA7Y29ubmVjdGFibGU9MTtmb250Q29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsxMCZxdW90OyB5PSZxdW90OzE5NCZxdW90OyB3aWR0aD0mcXVvdDs0MDAmcXVvdDsgaGVpZ2h0PSZxdW90OzE2MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0zJnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbGxpcHNlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YXNwZWN0PWZpeGVkO2ZpbGxDb2xvcj0jRkYzMzk5O3N0cm9rZVdpZHRoPTI7Z3JhZGllbnRDb2xvcj0jRkY2OUFGO2dyYWRpZW50RGlyZWN0aW9uPWVhc3Q7c2hhZG93PTE7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IHZlcnRleD0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHg9JnF1b3Q7MTQwJnF1b3Q7IHk9JnF1b3Q7NjQmcXVvdDsgd2lkdGg9JnF1b3Q7ODAmcXVvdDsgaGVpZ2h0PSZxdW90OzgwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTM4JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxNDMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTM5JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs0MyZxdW90OyB5PSZxdW90OzM4MiZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs0MyZxdW90OyB5PSZxdW90OzMyNyZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDAmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzMwJnF1b3Q7IHk9JnF1b3Q7MzczJnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzMwJnF1b3Q7IHk9JnF1b3Q7MzI3JnF1b3Q7IGFzPSZxdW90O3RhcmdldFBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy00MSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7cm91bmRlZD0wO3N0cm9rZVdpZHRoPTEwO2ZvbnRDb2xvcj0jMkIyQjJCO3N0cm9rZUNvbG9yPSMyQjJCMkI7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7ODMmcXVvdDsgeT0mcXVvdDszOTQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7ODMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTQyJnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs5NiZxdW90OyB5PSZxdW90OzM4NSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs5NiZxdW90OyB5PSZxdW90OzMyOSZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDUmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzEyMSZxdW90OyB5PSZxdW90OzM0MCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxMjEmcXVvdDsgeT0mcXVvdDszMzEmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTQ2JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs2MyZxdW90OyB5PSZxdW90OzM0NCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs2MyZxdW90OyB5PSZxdW90OzMyOCZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDcmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzEzNCZxdW90OyB5PSZxdW90OzM0NSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxMzQmcXVvdDsgeT0mcXVvdDszMjkmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O0d5Ym5IdHFxNEFDZW4tMXZxTGFZLTImcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsyNjAmcXVvdDsgeT0mcXVvdDs3NCZxdW90OyB3aWR0aD0mcXVvdDszMCZxdW90OyBoZWlnaHQ9JnF1b3Q7MzAmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAmbHQ7L3Jvb3QmZ3Q7JiMxMDsgICAgJmx0Oy9teEdyYXBoTW9kZWwmZ3Q7JiMxMDsgICZsdDsvZGlhZ3JhbSZndDsmIzEwOyZsdDsvbXhmaWxlJmd0OyYjMTA7Ij48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMCUiIGlkPSJteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTAiPjxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiByZ2IoMjU1LCA1MSwgMTUzKTsgc3RvcC1vcGFjaXR5OiAxOyIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IHJnYigyNTUsIDEwNSwgMTc1KTsgc3RvcC1vcGFjaXR5OiAxOyIvPjwvbGluZWFyR3JhZGllbnQ+PGZpbHRlciBpZD0iZHJvcFNoYWRvdyI+PGZlR2F1c3NpYW5CbHVyIGluPSJTb3VyY2VBbHBoYSIgc3RkRGV2aWF0aW9uPSIxLjciIHJlc3VsdD0iYmx1ciIvPjxmZU9mZnNldCBpbj0iYmx1ciIgZHg9IjMiIGR5PSIzIiByZXN1bHQ9Im9mZnNldEJsdXIiLz48ZmVGbG9vZCBmbG9vZC1jb2xvcj0iIzNENDU3NCIgZmxvb2Qtb3BhY2l0eT0iMC40IiByZXN1bHQ9Im9mZnNldENvbG9yIi8+PGZlQ29tcG9zaXRlIGluPSJvZmZzZXRDb2xvciIgaW4yPSJvZmZzZXRCbHVyIiBvcGVyYXRvcj0iaW4iIHJlc3VsdD0ib2Zmc2V0Qmx1ciIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9Im9mZnNldEJsdXIiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsdGVyPSJ1cmwoI2Ryb3BTaGFkb3cpIj48cGF0aCBkPSJNIDI2Ni40IDI2NS40IFEgMjk5LjQgMTQwLjQgMjY0LjQgNzUuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmYzMzk5IiBzdHJva2Utb3BhY2l0eT0iMC41IiBzdHJva2Utd2lkdGg9IjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjU5LjQgMjcwLjQgUSAzMTkuNCAxNDAuNCAxOTEuNCAzNC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSAyNjkuNCAyNTAuNCBRIDk5LjQgMTQwLjQgOTguNCAzMy40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjQ5LjQgMjYwLjQgUSAyNDEuNCAxNDAuNCAxNjguNCA5Mi40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMzAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjY3LjQgMjYwLjQgUSAxOTcuNCAxNjAuNCA0MC40IDExMC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMjAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjY5LjQgMjYwLjQgUSAxMzkuNCAxNjAuNCAzOS40IDE5MC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iNDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxlbGxpcHNlIGN4PSIyNzEuNCIgY3k9IjI2NC40IiByeD0iMTI5IiByeT0iMTI5IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIyNzEuNCIgY3k9IjI2NC40IiByeD0iMTI5IiByeT0iMTI5IiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZWxsaXBzZSBjeD0iNDkuNCIgY3k9IjE5MC40IiByeD0iNDAiIHJ5PSI0MCIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIsMykiIG9wYWNpdHk9IjAuMjUiLz48ZWxsaXBzZSBjeD0iNDkuNCIgY3k9IjE5MC40IiByeD0iNDAiIHJ5PSI0MCIgZmlsbD0idXJsKCNteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGVsbGlwc2UgY3g9IjE4OS40IiBjeT0iMzAuNCIgcng9IjIwIiByeT0iMjAiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyLDMpIiBvcGFjaXR5PSIwLjI1Ii8+PGVsbGlwc2UgY3g9IjE4OS40IiBjeT0iMzAuNCIgcng9IjIwIiByeT0iMjAiIGZpbGw9InVybCgjbXgtZ3JhZGllbnQtZmYzMzk5LTEtZmY2OWFmLTEtZS0wKSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxlbGxpcHNlIGN4PSIzOS40IiBjeT0iMTEwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIzOS40IiBjeT0iMTEwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZWxsaXBzZSBjeD0iOTkuNCIgY3k9IjMwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSI5OS40IiBjeT0iMzAuNCIgcng9IjMwIiByeT0iMzAiIGZpbGw9InVybCgjbXgtZ3JhZGllbnQtZmYzMzk5LTEtZmY2OWFmLTEtZS0wKSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxyZWN0IHg9Ii0wLjYiIHk9IjE4MC40IiB3aWR0aD0iNDAwIiBoZWlnaHQ9IjE2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDM5OHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDI2MHB4OyBtYXJnaW4tbGVmdDogMHB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjMkIyQjJCOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoNDMsIDQzLCA0Myk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPjxmb250IGZhY2U9ImltcGFjdCIgc3R5bGU9ImZvbnQtc2l6ZTogMTAwcHg7Ij5tcyBGZWFTVDwvZm9udD48L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMTk5IiB5PSIyNjQiIGZpbGw9IiMyQjJCMkIiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+bXMgRmVhU1Q8L3RleHQ+PC9zd2l0Y2g+PC9nPjxlbGxpcHNlIGN4PSIxNjkuNCIgY3k9IjkwLjQiIHJ4PSI0MCIgcnk9IjQwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIxNjkuNCIgY3k9IjkwLjQiIHJ4PSI0MCIgcnk9IjQwIiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cGF0aCBkPSJNIDEzMi40IDMxMy40IEwgMTIuNCAzMTMuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDMyLjQgMzY4LjQgTCAzMi40IDMxMy40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTkuNCAzNTkuNCBMIDE5LjQgMzEzLjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzJiMmIyYiIgc3Ryb2tlLXdpZHRoPSIxMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSA3Mi40IDM4MC40IEwgNzIuNCAzMTMuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDg1LjQgMzcxLjQgTCA4NS40IDMxNS40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTEwLjQgMzI2LjQgTCAxMTAuNCAzMTcuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDUyLjQgMzMwLjQgTCA1Mi40IDMxNC40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTIzLjQgMzMxLjQgTCAxMjMuNCAzMTUuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48ZWxsaXBzZSBjeD0iMjY0LjQiIGN5PSI3NS40IiByeD0iMTUiIHJ5PSIxNSIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIsMykiIG9wYWNpdHk9IjAuMjUiLz48ZWxsaXBzZSBjeD0iMjY0LjQiIGN5PSI3NS40IiByeD0iMTUiIHJ5PSIxNSIgZmlsbD0idXJsKCNteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRyYXdpby5jb20vZG9jL2ZhcS9zdmctZXhwb3J0LXRleHQtcHJvYmxlbXMiIHRhcmdldD0iX2JsYW5rIj48dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjEwcHgiIHg9IjUwJSIgeT0iMTAwJSI+VGV4dCBpcyBub3QgU1ZHIC0gY2Fubm90IGRpc3BsYXk8L3RleHQ+PC9hPjwvc3dpdGNoPjwvc3ZnPg==" style="cursor:pointer;max-width:100%;"onclick="(function(img){if(img.wnd!=null&&!img.wnd.closed){img.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&&evt.source==img.wnd){img.wnd.postMessage(decodeURIComponent(img.getAttribute('src')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);img.wnd=window.open('https://viewer.diagrams.net/?client=1');}})(this);">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    .visjsNetworkContainer {
  width: 100%;
  height: 70vh;
  border: 1px solid lightgray;
}

.plotlyGraphContainer {
  width: 100%;
  height: 60vh;
  border: 5px black;
  align-content: center;
  overflow: auto; /*must have for plotly resizing to work in bootstrap tabs!*/
}

.nodeInfoText {
  font-family: Helvetica;
  font-size: 1rem;
  color: rgb(235,16,162, 0.7);;
}

.heatmapPanel {
  width: 100%;
  height: 15vh;
  border: 5px black;
  align-content: center;
  overflow: auto; /*must have for plotly resizing to work in bootstrap tabs!*/
}

.colorBarPanel {
  width: 80%;
  height: 10vh;
  border: 5px black;
  align-content: center;
  overflow: auto; /*must have for plotly resizing to work in bootstrap tabs!*/
}

.customWarningStyle {
  color: rgb(235,16,162, 0.8);
}

.navbar {
  background-color: rgba(241, 241, 241, 0.96);
}

.navbar-brand {
  font-family: 'Helvetica';
}


.nav-pills .nav-link.active, .nav-pills .show > .nav-link {
  background-color: rgb(235,16,162, 0.7);
}


.nav-link {
  color: black;
  background-color: rgba(128, 128, 128, 0.4);
  
}


body {
  font-size: 10px; 
  font-family: 'Helvetica';
}

html {
  font-size: 70%;
}
body {
  font-size: 1rem;
}
header {
  font-size: 2rem;
}

.vis-tooltip {
  font-family: 'Helvetica' !important;
  color: #000000  !important; /* Change the font color */
  background-color: rgb(234, 234, 234) !important; /* Change the background color */
  border: 1px solid #808074  !important; /* Change the border */
  border-radius: 3px  !important; /* Add rounded corners */
  padding: 5px  !important; /* Add some padding */
}

.logo-image{
  width: 45px;
  height: 45px;
  padding-top: 0;
  padding-bottom: 0;
  margin-top: 0;
  margin-bottom: 0;
  display: inline-block;
}
  </style>
  <title>msFeaST</title>
  <!-- defer keyword means all html elements are loaded before these scripts are run. new approach over end of body. -->
  <script defer src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.css" integrity="sha512-NJXM8vzWgDcBy9SCUTJXYnNO43sZV3pfLWWZMFTuCtEUIOcznk+AMpH6N3XruxavYfMeMmjrzDMEQ6psRh/6Hw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js" integrity="sha512-GE9mKnPrTn2DY5AZuIC9yE6K4FF8T+9lsO7jwHn+RW9rEjnHzF/in0oGwlPzRwjhQ+oJiawmtfvleX+l6h5/cA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js" integrity="sha512-XHDcSyqhOoO2ocB7sKOCJEkUjw/pQCJViP1ynpy+EGh/LggzrP6U/V3a++LQTnZT7sCQKeHRyWHfhN2afjXjCg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Navbar --------------------------------------------------------------------------------------------------------->
  <nav class="navbar navbar-default navbar-light">
    <div class="container-fluid"> 
      <div class="navbar-header">
        <a class="navbar-brand" href="#"> 
          <a class="navbar-brand" href="/">
            <div class="logo-image">
              <img class="img-fluid" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0MTAiIGhlaWdodD0iNDA1IiB2aWV3Qm94PSItMC41IC0wLjUgNDEwIDQwNSIgY29udGVudD0iJmx0O214ZmlsZSBob3N0PSZxdW90O0VsZWN0cm9uJnF1b3Q7IG1vZGlmaWVkPSZxdW90OzIwMjQtMDMtMjdUMTU6MzA6MzEuMTgxWiZxdW90OyBhZ2VudD0mcXVvdDtNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNV83KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBkcmF3LmlvLzIyLjAuMyBDaHJvbWUvMTE0LjAuNTczNS4yODkgRWxlY3Ryb24vMjUuOC40IFNhZmFyaS81MzcuMzYmcXVvdDsgZXRhZz0mcXVvdDtCanFfX3lWQmoydC1NZzB3bFN2SSZxdW90OyB2ZXJzaW9uPSZxdW90OzIyLjAuMyZxdW90OyB0eXBlPSZxdW90O2RldmljZSZxdW90OyZndDsmIzEwOyAgJmx0O2RpYWdyYW0gbmFtZT0mcXVvdDtQYWdlLTEmcXVvdDsgaWQ9JnF1b3Q7X1pHcFRXOFhCNWRoY1pmUThQYTUmcXVvdDsmZ3Q7JiMxMDsgICAgJmx0O214R3JhcGhNb2RlbCBkeD0mcXVvdDsxMDE2LjQmcXVvdDsgZHk9JnF1b3Q7NzMzLjQmcXVvdDsgZ3JpZD0mcXVvdDsxJnF1b3Q7IGdyaWRTaXplPSZxdW90OzEwJnF1b3Q7IGd1aWRlcz0mcXVvdDswJnF1b3Q7IHRvb2x0aXBzPSZxdW90OzEmcXVvdDsgY29ubmVjdD0mcXVvdDsxJnF1b3Q7IGFycm93cz0mcXVvdDsxJnF1b3Q7IGZvbGQ9JnF1b3Q7MSZxdW90OyBwYWdlPSZxdW90OzEmcXVvdDsgcGFnZVNjYWxlPSZxdW90OzAuMTImcXVvdDsgcGFnZVdpZHRoPSZxdW90OzQwJnF1b3Q7IHBhZ2VIZWlnaHQ9JnF1b3Q7NDAmcXVvdDsgYmFja2dyb3VuZD0mcXVvdDtub25lJnF1b3Q7IG1hdGg9JnF1b3Q7MCZxdW90OyBzaGFkb3c9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICZsdDtyb290Jmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90OzAmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDsxJnF1b3Q7IHBhcmVudD0mcXVvdDswJnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7R3libkh0cXE0QUNlbi0xdnFMYVktMSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9NTtmaWxsQ29sb3I9I2UxZDVlNztzdHJva2VDb2xvcj0jRkYzMzk5O29wYWNpdHk9NTA7c2hhZG93PTA7bGFiZWxCb3JkZXJDb2xvcj1ub25lOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzI3NyZxdW90OyB5PSZxdW90OzI3OSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNzUmcXVvdDsgeT0mcXVvdDs4OSZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDszMTAmcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yOSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9NTtmaWxsQ29sb3I9I2UxZDVlNztzdHJva2VDb2xvcj0jRkYzMzk5O29wYWNpdHk9NTA7c2hhZG93PTA7bGFiZWxCb3JkZXJDb2xvcj1ub25lOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzI3MCZxdW90OyB5PSZxdW90OzI4NCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyMDImcXVvdDsgeT0mcXVvdDs0OCZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDszMzAmcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yOCZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9MTA7ZmlsbENvbG9yPSNlMWQ1ZTc7c3Ryb2tlQ29sb3I9I0ZGMzM5OTtvcGFjaXR5PTUwO3NoYWRvdz0wO2xhYmVsQm9yZGVyQ29sb3I9bm9uZTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyODAmcXVvdDsgeT0mcXVvdDsyNjQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MTA5JnF1b3Q7IHk9JnF1b3Q7NDcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtBcnJheSBhcz0mcXVvdDtwb2ludHMmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MTEwJnF1b3Q7IHk9JnF1b3Q7MTU0JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7L0FycmF5Jmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMjcmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO2N1cnZlZD0xO3N0cm9rZVdpZHRoPTMwO2ZpbGxDb2xvcj0jZTFkNWU3O3N0cm9rZUNvbG9yPSNGRjMzOTk7b3BhY2l0eT01MDtzaGFkb3c9MDtsYWJlbEJvcmRlckNvbG9yPW5vbmU7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjYwJnF1b3Q7IHk9JnF1b3Q7Mjc0JnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzE3OSZxdW90OyB5PSZxdW90OzEwNiZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O0FycmF5IGFzPSZxdW90O3BvaW50cyZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNTImcXVvdDsgeT0mcXVvdDsxNTQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDsvQXJyYXkmZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0yNiZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7Y3VydmVkPTE7c3Ryb2tlV2lkdGg9MjA7ZmlsbENvbG9yPSNlMWQ1ZTc7c3Ryb2tlQ29sb3I9I0ZGMzM5OTtvcGFjaXR5PTUwO3NoYWRvdz0wO2xhYmVsQm9yZGVyQ29sb3I9bm9uZTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsyNzgmcXVvdDsgeT0mcXVvdDsyNzQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7NTEmcXVvdDsgeT0mcXVvdDsxMjQmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtBcnJheSBhcz0mcXVvdDtwb2ludHMmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjA4JnF1b3Q7IHk9JnF1b3Q7MTc0JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7L0FycmF5Jmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMjMmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO2N1cnZlZD0xO3N0cm9rZVdpZHRoPTQwO2ZpbGxDb2xvcj0jZTFkNWU3O3N0cm9rZUNvbG9yPSNGRjMzOTk7b3BhY2l0eT01MDtzaGFkb3c9MDtsYWJlbEJvcmRlckNvbG9yPW5vbmU7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjgwJnF1b3Q7IHk9JnF1b3Q7Mjc0JnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzUwJnF1b3Q7IHk9JnF1b3Q7MjA0JnF1b3Q7IGFzPSZxdW90O3RhcmdldFBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7QXJyYXkgYXM9JnF1b3Q7cG9pbnRzJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzE1MCZxdW90OyB5PSZxdW90OzE3NCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0Oy9BcnJheSZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTEmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsxNTMmcXVvdDsgeT0mcXVvdDsxNDkmcXVvdDsgd2lkdGg9JnF1b3Q7MjU4JnF1b3Q7IGhlaWdodD0mcXVvdDsyNTgmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtMiZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FzcGVjdD1maXhlZDtmaWxsQ29sb3I9I0ZGMzM5OTtzdHJva2VXaWR0aD0yO2dyYWRpZW50Q29sb3I9I0ZGNjlBRjtncmFkaWVudERpcmVjdGlvbj1lYXN0O3NoYWRvdz0xOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyB2ZXJ0ZXg9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB4PSZxdW90OzIwJnF1b3Q7IHk9JnF1b3Q7MTY0JnF1b3Q7IHdpZHRoPSZxdW90OzgwJnF1b3Q7IGhlaWdodD0mcXVvdDs4MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy00JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbGxpcHNlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YXNwZWN0PWZpeGVkO2ZpbGxDb2xvcj0jRkYzMzk5O3N0cm9rZVdpZHRoPTI7Z3JhZGllbnRDb2xvcj0jRkY2OUFGO2dyYWRpZW50RGlyZWN0aW9uPWVhc3Q7c2hhZG93PTE7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IHZlcnRleD0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHg9JnF1b3Q7MTgwJnF1b3Q7IHk9JnF1b3Q7MjQmcXVvdDsgd2lkdGg9JnF1b3Q7NDAmcXVvdDsgaGVpZ2h0PSZxdW90OzQwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTkmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsyMCZxdW90OyB5PSZxdW90Ozk0JnF1b3Q7IHdpZHRoPSZxdW90OzYwJnF1b3Q7IGhlaWdodD0mcXVvdDs2MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0xMCZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FzcGVjdD1maXhlZDtmaWxsQ29sb3I9I0ZGMzM5OTtzdHJva2VXaWR0aD0yO2dyYWRpZW50Q29sb3I9I0ZGNjlBRjtncmFkaWVudERpcmVjdGlvbj1lYXN0O3NoYWRvdz0xOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyB2ZXJ0ZXg9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB4PSZxdW90OzgwJnF1b3Q7IHk9JnF1b3Q7MTQmcXVvdDsgd2lkdGg9JnF1b3Q7NjAmcXVvdDsgaGVpZ2h0PSZxdW90OzYwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTExJnF1b3Q7IHZhbHVlPSZxdW90OyZhbXA7bHQ7Zm9udCBzdHlsZT0mYW1wO3F1b3Q7Zm9udC1zaXplOiAxMDBweDsmYW1wO3F1b3Q7IGZhY2U9JmFtcDtxdW90O2ltcGFjdCZhbXA7cXVvdDsmYW1wO2d0O21zIEZlYVNUJmFtcDtsdDsvZm9udCZhbXA7Z3Q7JnF1b3Q7IHN0eWxlPSZxdW90O3RleHQ7aHRtbD0xO3N0cm9rZUNvbG9yPW5vbmU7ZmlsbENvbG9yPW5vbmU7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3doaXRlU3BhY2U9d3JhcDtyb3VuZGVkPTA7bW92YWJsZT0xO3Jlc2l6YWJsZT0xO3JvdGF0YWJsZT0xO2RlbGV0YWJsZT0xO2VkaXRhYmxlPTE7bG9ja2VkPTA7Y29ubmVjdGFibGU9MTtmb250Q29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsxMCZxdW90OyB5PSZxdW90OzE5NCZxdW90OyB3aWR0aD0mcXVvdDs0MDAmcXVvdDsgaGVpZ2h0PSZxdW90OzE2MCZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy0zJnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbGxpcHNlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YXNwZWN0PWZpeGVkO2ZpbGxDb2xvcj0jRkYzMzk5O3N0cm9rZVdpZHRoPTI7Z3JhZGllbnRDb2xvcj0jRkY2OUFGO2dyYWRpZW50RGlyZWN0aW9uPWVhc3Q7c2hhZG93PTE7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IHZlcnRleD0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHg9JnF1b3Q7MTQwJnF1b3Q7IHk9JnF1b3Q7NjQmcXVvdDsgd2lkdGg9JnF1b3Q7ODAmcXVvdDsgaGVpZ2h0PSZxdW90OzgwJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTM4JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxNDMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7MjMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTM5JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs0MyZxdW90OyB5PSZxdW90OzM4MiZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs0MyZxdW90OyB5PSZxdW90OzMyNyZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDAmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzMwJnF1b3Q7IHk9JnF1b3Q7MzczJnF1b3Q7IGFzPSZxdW90O3NvdXJjZVBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzMwJnF1b3Q7IHk9JnF1b3Q7MzI3JnF1b3Q7IGFzPSZxdW90O3RhcmdldFBvaW50JnF1b3Q7IC8mZ3Q7JiMxMDsgICAgICAgICAgJmx0Oy9teEdlb21ldHJ5Jmd0OyYjMTA7ICAgICAgICAmbHQ7L214Q2VsbCZndDsmIzEwOyAgICAgICAgJmx0O214Q2VsbCBpZD0mcXVvdDtNYmdRR1FDQ3lEcnoxb09TMW85Uy00MSZxdW90OyB2YWx1ZT0mcXVvdDsmcXVvdDsgc3R5bGU9JnF1b3Q7ZW5kQXJyb3c9bm9uZTtodG1sPTE7cm91bmRlZD0wO3N0cm9rZVdpZHRoPTEwO2ZvbnRDb2xvcj0jMkIyQjJCO3N0cm9rZUNvbG9yPSMyQjJCMkI7JnF1b3Q7IHBhcmVudD0mcXVvdDsxJnF1b3Q7IGVkZ2U9JnF1b3Q7MSZxdW90OyZndDsmIzEwOyAgICAgICAgICAmbHQ7bXhHZW9tZXRyeSB3aWR0aD0mcXVvdDs1MCZxdW90OyBoZWlnaHQ9JnF1b3Q7NTAmcXVvdDsgcmVsYXRpdmU9JnF1b3Q7MSZxdW90OyBhcz0mcXVvdDtnZW9tZXRyeSZxdW90OyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7ODMmcXVvdDsgeT0mcXVvdDszOTQmcXVvdDsgYXM9JnF1b3Q7c291cmNlUG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAgICZsdDtteFBvaW50IHg9JnF1b3Q7ODMmcXVvdDsgeT0mcXVvdDszMjcmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTQyJnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs5NiZxdW90OyB5PSZxdW90OzM4NSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs5NiZxdW90OyB5PSZxdW90OzMyOSZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDUmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzEyMSZxdW90OyB5PSZxdW90OzM0MCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxMjEmcXVvdDsgeT0mcXVvdDszMzEmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O01iZ1FHUUNDeURyejFvT1MxbzlTLTQ2JnF1b3Q7IHZhbHVlPSZxdW90OyZxdW90OyBzdHlsZT0mcXVvdDtlbmRBcnJvdz1ub25lO2h0bWw9MTtyb3VuZGVkPTA7c3Ryb2tlV2lkdGg9MTA7Zm9udENvbG9yPSMyQjJCMkI7c3Ryb2tlQ29sb3I9IzJCMkIyQjsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgZWRnZT0mcXVvdDsxJnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICZsdDtteEdlb21ldHJ5IHdpZHRoPSZxdW90OzUwJnF1b3Q7IGhlaWdodD0mcXVvdDs1MCZxdW90OyByZWxhdGl2ZT0mcXVvdDsxJnF1b3Q7IGFzPSZxdW90O2dlb21ldHJ5JnF1b3Q7Jmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs2MyZxdW90OyB5PSZxdW90OzM0NCZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDs2MyZxdW90OyB5PSZxdW90OzMyOCZxdW90OyBhcz0mcXVvdDt0YXJnZXRQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICZsdDsvbXhHZW9tZXRyeSZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAgICZsdDtteENlbGwgaWQ9JnF1b3Q7TWJnUUdRQ0N5RHJ6MW9PUzFvOVMtNDcmcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VuZEFycm93PW5vbmU7aHRtbD0xO3JvdW5kZWQ9MDtzdHJva2VXaWR0aD0xMDtmb250Q29sb3I9IzJCMkIyQjtzdHJva2VDb2xvcj0jMkIyQjJCOyZxdW90OyBwYXJlbnQ9JnF1b3Q7MSZxdW90OyBlZGdlPSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgd2lkdGg9JnF1b3Q7NTAmcXVvdDsgaGVpZ2h0PSZxdW90OzUwJnF1b3Q7IHJlbGF0aXZlPSZxdW90OzEmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgICAmbHQ7bXhQb2ludCB4PSZxdW90OzEzNCZxdW90OyB5PSZxdW90OzM0NSZxdW90OyBhcz0mcXVvdDtzb3VyY2VQb2ludCZxdW90OyAvJmd0OyYjMTA7ICAgICAgICAgICAgJmx0O214UG9pbnQgeD0mcXVvdDsxMzQmcXVvdDsgeT0mcXVvdDszMjkmcXVvdDsgYXM9JnF1b3Q7dGFyZ2V0UG9pbnQmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgICAmbHQ7L214R2VvbWV0cnkmZ3Q7JiMxMDsgICAgICAgICZsdDsvbXhDZWxsJmd0OyYjMTA7ICAgICAgICAmbHQ7bXhDZWxsIGlkPSZxdW90O0d5Ym5IdHFxNEFDZW4tMXZxTGFZLTImcXVvdDsgdmFsdWU9JnF1b3Q7JnF1b3Q7IHN0eWxlPSZxdW90O2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthc3BlY3Q9Zml4ZWQ7ZmlsbENvbG9yPSNGRjMzOTk7c3Ryb2tlV2lkdGg9MjtncmFkaWVudENvbG9yPSNGRjY5QUY7Z3JhZGllbnREaXJlY3Rpb249ZWFzdDtzaGFkb3c9MTsmcXVvdDsgcGFyZW50PSZxdW90OzEmcXVvdDsgdmVydGV4PSZxdW90OzEmcXVvdDsmZ3Q7JiMxMDsgICAgICAgICAgJmx0O214R2VvbWV0cnkgeD0mcXVvdDsyNjAmcXVvdDsgeT0mcXVvdDs3NCZxdW90OyB3aWR0aD0mcXVvdDszMCZxdW90OyBoZWlnaHQ9JnF1b3Q7MzAmcXVvdDsgYXM9JnF1b3Q7Z2VvbWV0cnkmcXVvdDsgLyZndDsmIzEwOyAgICAgICAgJmx0Oy9teENlbGwmZ3Q7JiMxMDsgICAgICAmbHQ7L3Jvb3QmZ3Q7JiMxMDsgICAgJmx0Oy9teEdyYXBoTW9kZWwmZ3Q7JiMxMDsgICZsdDsvZGlhZ3JhbSZndDsmIzEwOyZsdDsvbXhmaWxlJmd0OyYjMTA7Ij48ZGVmcz48bGluZWFyR3JhZGllbnQgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMCUiIGlkPSJteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTAiPjxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiByZ2IoMjU1LCA1MSwgMTUzKTsgc3RvcC1vcGFjaXR5OiAxOyIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IHJnYigyNTUsIDEwNSwgMTc1KTsgc3RvcC1vcGFjaXR5OiAxOyIvPjwvbGluZWFyR3JhZGllbnQ+PGZpbHRlciBpZD0iZHJvcFNoYWRvdyI+PGZlR2F1c3NpYW5CbHVyIGluPSJTb3VyY2VBbHBoYSIgc3RkRGV2aWF0aW9uPSIxLjciIHJlc3VsdD0iYmx1ciIvPjxmZU9mZnNldCBpbj0iYmx1ciIgZHg9IjMiIGR5PSIzIiByZXN1bHQ9Im9mZnNldEJsdXIiLz48ZmVGbG9vZCBmbG9vZC1jb2xvcj0iIzNENDU3NCIgZmxvb2Qtb3BhY2l0eT0iMC40IiByZXN1bHQ9Im9mZnNldENvbG9yIi8+PGZlQ29tcG9zaXRlIGluPSJvZmZzZXRDb2xvciIgaW4yPSJvZmZzZXRCbHVyIiBvcGVyYXRvcj0iaW4iIHJlc3VsdD0ib2Zmc2V0Qmx1ciIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9Im9mZnNldEJsdXIiLz48L2ZpbHRlcj48L2RlZnM+PGcgZmlsdGVyPSJ1cmwoI2Ryb3BTaGFkb3cpIj48cGF0aCBkPSJNIDI2Ni40IDI2NS40IFEgMjk5LjQgMTQwLjQgMjY0LjQgNzUuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmYzMzk5IiBzdHJva2Utb3BhY2l0eT0iMC41IiBzdHJva2Utd2lkdGg9IjUiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjU5LjQgMjcwLjQgUSAzMTkuNCAxNDAuNCAxOTEuNCAzNC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iNSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSAyNjkuNCAyNTAuNCBRIDk5LjQgMTQwLjQgOTguNCAzMy40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjQ5LjQgMjYwLjQgUSAyNDEuNCAxNDAuNCAxNjguNCA5Mi40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMzAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjY3LjQgMjYwLjQgUSAxOTcuNCAxNjAuNCA0MC40IDExMC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iMjAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjY5LjQgMjYwLjQgUSAxMzkuNCAxNjAuNCAzOS40IDE5MC40IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZjMzOTkiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZS13aWR0aD0iNDAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxlbGxpcHNlIGN4PSIyNzEuNCIgY3k9IjI2NC40IiByeD0iMTI5IiByeT0iMTI5IiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIyNzEuNCIgY3k9IjI2NC40IiByeD0iMTI5IiByeT0iMTI5IiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZWxsaXBzZSBjeD0iNDkuNCIgY3k9IjE5MC40IiByeD0iNDAiIHJ5PSI0MCIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIsMykiIG9wYWNpdHk9IjAuMjUiLz48ZWxsaXBzZSBjeD0iNDkuNCIgY3k9IjE5MC40IiByeD0iNDAiIHJ5PSI0MCIgZmlsbD0idXJsKCNteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGVsbGlwc2UgY3g9IjE4OS40IiBjeT0iMzAuNCIgcng9IjIwIiByeT0iMjAiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyLDMpIiBvcGFjaXR5PSIwLjI1Ii8+PGVsbGlwc2UgY3g9IjE4OS40IiBjeT0iMzAuNCIgcng9IjIwIiByeT0iMjAiIGZpbGw9InVybCgjbXgtZ3JhZGllbnQtZmYzMzk5LTEtZmY2OWFmLTEtZS0wKSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxlbGxpcHNlIGN4PSIzOS40IiBjeT0iMTEwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIzOS40IiBjeT0iMTEwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZWxsaXBzZSBjeD0iOTkuNCIgY3k9IjMwLjQiIHJ4PSIzMCIgcnk9IjMwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSI5OS40IiBjeT0iMzAuNCIgcng9IjMwIiByeT0iMzAiIGZpbGw9InVybCgjbXgtZ3JhZGllbnQtZmYzMzk5LTEtZmY2OWFmLTEtZS0wKSIgc3Ryb2tlPSJyZ2IoMCwgMCwgMCkiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxyZWN0IHg9Ii0wLjYiIHk9IjE4MC40IiB3aWR0aD0iNDAwIiBoZWlnaHQ9IjE2MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDM5OHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDI2MHB4OyBtYXJnaW4tbGVmdDogMHB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjMkIyQjJCOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoNDMsIDQzLCA0Myk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPjxmb250IGZhY2U9ImltcGFjdCIgc3R5bGU9ImZvbnQtc2l6ZTogMTAwcHg7Ij5tcyBGZWFTVDwvZm9udD48L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMTk5IiB5PSIyNjQiIGZpbGw9IiMyQjJCMkIiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTJweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+bXMgRmVhU1Q8L3RleHQ+PC9zd2l0Y2g+PC9nPjxlbGxpcHNlIGN4PSIxNjkuNCIgY3k9IjkwLjQiIHJ4PSI0MCIgcnk9IjQwIiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMiIgcG9pbnRlci1ldmVudHM9ImFsbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiwzKSIgb3BhY2l0eT0iMC4yNSIvPjxlbGxpcHNlIGN4PSIxNjkuNCIgY3k9IjkwLjQiIHJ4PSI0MCIgcnk9IjQwIiBmaWxsPSJ1cmwoI214LWdyYWRpZW50LWZmMzM5OS0xLWZmNjlhZi0xLWUtMCkiIHN0cm9rZT0icmdiKDAsIDAsIDApIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cGF0aCBkPSJNIDEzMi40IDMxMy40IEwgMTIuNCAzMTMuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDMyLjQgMzY4LjQgTCAzMi40IDMxMy40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTkuNCAzNTkuNCBMIDE5LjQgMzEzLjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzJiMmIyYiIgc3Ryb2tlLXdpZHRoPSIxMCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSA3Mi40IDM4MC40IEwgNzIuNCAzMTMuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDg1LjQgMzcxLjQgTCA4NS40IDMxNS40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTEwLjQgMzI2LjQgTCAxMTAuNCAzMTcuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDUyLjQgMzMwLjQgTCA1Mi40IDMxNC40IiBmaWxsPSJub25lIiBzdHJva2U9IiMyYjJiMmIiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMTIzLjQgMzMxLjQgTCAxMjMuNCAzMTUuNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMmIyYjJiIiBzdHJva2Utd2lkdGg9IjEwIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48ZWxsaXBzZSBjeD0iMjY0LjQiIGN5PSI3NS40IiByeD0iMTUiIHJ5PSIxNSIgZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjIiIHBvaW50ZXItZXZlbnRzPSJhbGwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIsMykiIG9wYWNpdHk9IjAuMjUiLz48ZWxsaXBzZSBjeD0iMjY0LjQiIGN5PSI3NS40IiByeD0iMTUiIHJ5PSIxNSIgZmlsbD0idXJsKCNteC1ncmFkaWVudC1mZjMzOTktMS1mZjY5YWYtMS1lLTApIiBzdHJva2U9InJnYigwLCAwLCAwKSIgc3Ryb2tlLXdpZHRoPSIyIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRyYXdpby5jb20vZG9jL2ZhcS9zdmctZXhwb3J0LXRleHQtcHJvYmxlbXMiIHRhcmdldD0iX2JsYW5rIj48dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjEwcHgiIHg9IjUwJSIgeT0iMTAwJSI+VGV4dCBpcyBub3QgU1ZHIC0gY2Fubm90IGRpc3BsYXk8L3RleHQ+PC9hPjwvc3dpdGNoPjwvc3ZnPg==" style="cursor:pointer;max-width:100%;"onclick="(function(img){if(img.wnd!=null&&!img.wnd.closed){img.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&&evt.source==img.wnd){img.wnd.postMessage(decodeURIComponent(img.getAttribute('src')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);img.wnd=window.open('https://viewer.diagrams.net/?client=1');}})(this);"/>
            </div>
      </a>
        </a>
      </div>
      <!-- Actual navbar items are stored in a list-->
      <ul class="nav nav-pills" id="myNavigationPills" role="tablist">
        <li class="nav-item">
          <a 
            class="nav-link active" 
            id="pills-settings-tab" 
            data-toggle="tab" h
            ref="#settings-tab" 
            data-bs-toggle="pill" 
            data-bs-target="#settings-tab" 
            type="button" 
            role="tab" 
            aria-controls="pills-home" 
            aria-selected="true"
          >
            Data Loading
          </a>
        </li>
        <li class="nav-item">
          <a 
            class="nav-link" 
            id="pills-visual-tab" 
            data-toggle="tab" 
            data-bs-toggle="pill" 
            data-bs-target="#visualization-tab" 
            type="button" role="tab" 
            aria-controls="pills-home" 
            aria-selected="false"
          >
            Data View
          </a>
        </li>
      </ul>
    </div>
  </nav>
  <!-- Page Components ------------------------------------------------------------------------------------------------>
  <div class="container-fluid tab-content">
    <div id="visualization-tab" class="tab-pane">
      <br/>
      <div class="row">
        <div class="col-8">
          <div id="id-visjs-network-example" class = "visjsNetworkContainer" overflow="hidden"> 
            <div class="vis-tooltip" style="left: 0px; top: 0px; visibility: hidden;"><br></div>
          </div>
          <div id="id_heatmap" class = "heatmapPanel"></div>
          <div id="id_color_bar" class = "colorBarPanel"></div>
        </div>
        <div class="col-4">
          <div class="row">
            Interactive node information display (click on node):  
          </div>
          <div class="row">
            <pre id="id-node-information" class="nodeInfoText""></pre>
          </div>
          <br/>
          <div class="row"> Select Contrast:
          </div>
          <select id="id-contrast-selector" class="form-select" size="1" aria-label="Contrast Selector"> </select>
          <div class="row">
            Select univ. statistical measure: 
          </div>
          <select  id="id-univ-measure-selector" class="form-select" size="1" aria-label="Measure Selector"> </select>
          <br/>
          <div class="row">
            Apply Min-Max Scaling to Original Coordinate System: <br/> 
            Set scaling factor between 1 and 9999 (range = [factor * -1, factor * 1]).
          </div>
          <input id="id-graph-scaler" class="form-control" type="number" placeholder=200>
          <div class="row">
            Run network stabilization physics n iterations: <br/>
            This pushes overlapping nodes away from each other. Use a value between 1 and 10 and press enter repeatedly.
          </div>
          <input id="id-network-physics" class="form-control" type="number" placeholder=1>
          <div class="row">
            Set maximum number of edges to be visualized when clicking a node. <br/>
            <div id="id-topk-live-print">Selected top-K value: 10</div>
          </div>
          <input id="id-topk-range-input" type="range" class="form-control-range" id="formControlRange" min="1" max="50" step="1" value="10">

        </div>
      </div>
    </div>
    <div id="settings-tab" class="tab-pane active">
      <br/>
      <div class="row">
        <div class="col-6">
          <form id="jsonFile" name="jsonFile" enctype="multipart/form-data" method="post">
            <fieldset>
              <h1>Import Session Data</h1>
               <input type='file' id='id-file-input'>
            </fieldset>
          </form>
          <br/>
          <input type='button' id='id-button-load-json' value='Load Selected Data'>
        </div>
        <div class="col-6">
        </div>
      </div>
    </div>
  </div>
  <script> 
    // Combined javascript 

// DOM References
const networkContainer = document.getElementById("id-visjs-network-example");
const nodeInfoContainer = document.getElementById("id-node-information");
const jsonPrintContainer = document.getElementById("id-json-print-container");
const buttonLoadJsonData = document.getElementById("id-button-load-json");
const fromTopkSelector = document.getElementById("id-topk-range-input");
const topkLivePrintContainer = document.getElementById("id-topk-live-print");
const formSelectContrast = document.getElementById("id-contrast-selector" );
const formSelectUnivMeasure = document.getElementById("id-univ-measure-selector");
const heatmapContainer = document.getElementById("id_heatmap");
const runNetworkPhysicsInput = document.getElementById("id-network-physics");
const colorBarContainer = document.getElementById('id_color_bar');
const scalingInput = document.getElementById("id-graph-scaler");

// Styling Variables
const stylingVariables = {
  colorHighlight: "rgb(235,16,162, 0.8)",
  defaultEdgeColor: "#A65A8D",
  defaultNodeColor: "rgb(166, 90, 141, 0.25)", 
  defaultNodeBorderColor: "rgb(0, 0, 0, 0.25)"
};

let heatmapPanelController = function(groupStats, domElementContrast, networkDrawingOptions, network, highlightGroupId = undefined){
  // Constructs heatmap with global test set specific results
  // Dev Note: Assumes n_measures at set level is equal to 1!
  let colorscale = 'Greys'; // Greys, Rainbow, Portland (diverging), Jet, Hot has clear low end separation
  let margin = 10;

  /** Function creates xTicks with highlight style if provided a highlight group
   *  
   * @param {*} groupIdentifiers array of identifiers 
   * @param {*} highlightGroup the identifier to be highlighted in the axis text
   * @returns 
   */
  let generateXaxisTicks = function(groupIdentifiers, highlightGroup){
    let xTicks = [];
    for (tick of groupIdentifiers){
      if (tick === highlightGroup){
        xTicks.push(`<span style='font-weight:bold;font-size:100%;color:${stylingVariables["colorHighlight"]}'>${String(tick)}</span>`)
      } else {
        xTicks.push(tick)
      }
    }
    return xTicks
  }
  /** Function constructs heatmap trace and layout from groupStats data
   *  
   * @param {*} groupStats 
   * @returns 
   */
  let constructHeatmapData = function(groupStats, colorscale, margin, highlightGroupId){
    let xVals = Object.keys(groupStats);
    let xTicks = generateXaxisTicks(xVals, highlightGroupId);
    let yTicks = Array.from(domElementContrast.options).map(option => option.value); // Change global access to local data!
    // get array of p-values for all constrat
    let globalTestPValuesArray = [];
    for (let current_contrast of yTicks) {
      tmp_array = [];
      for (let current_group of xVals) {
        tmp_array.push(groupStats[current_group][current_contrast]["globalTestPValue"]);
      }
      globalTestPValuesArray.push(tmp_array);
    }
    let heatmapTrace = [{
      z: globalTestPValuesArray,
      x: xVals,
      y: yTicks,
      zmin: 0,  // Minimum color value
      zmax: 1,   // Maximum color value
      colorscale: colorscale, // [[0, 'white'], [1, 'blue']], // for custom color scale
      showscale : false,
      //reversescale : true,
      type: 'heatmap',
      hovertemplate: 'x: %{x}<br>y: %{y}<br>z: %{z:.2e}<extra></extra>'
    }];
    var heatmapLayout = {
      margin: {t:margin, l:margin},
      xaxis: {automargin : true, tickmode: "array", dtick:1, tickfont : {size : 8} ,tickvals: xVals, ticktext : xTicks}, // 
      yaxis: {automargin : true, side: "right"},
      title: '',
      autosize: true,
    };
    return {trace : heatmapTrace, layout: heatmapLayout};
  };

  /** Functions returns colorbar trace and layout for heatmap. Currently largely a static object constructor.
   */
  const constructColorBarData = function(colorscale, margin){
    let scale_values = Array.from({length: 101}, (_, i) => i * 0.01);
    let colorBarTrace = [{
      z: [scale_values], // This should match the color levels of your original heatmap
      x: scale_values,
      y: ["P-value color gradient"],
      type: 'heatmap',
      colorscale: colorscale,
      showscale : false,
      xaxis: 'p-value',
      yaxis: ['color'],
      hovertemplate: 'p-value: %{x}<br><extra></extra>',
    }];
    let colorBarLayout = {
      title : "",
      margin: {l: margin,r: margin,b: margin, t: margin}, 
      xaxis: {automargin : true, domain: [0, 1], tickfont : {size : 8}, anchor: 'y'},
      yaxis: {anchor: 'x', automargin : true, showticklabels: true, side: "right", tickmode: "linear", dtick:1},
      autosize: true, // Automatically adjust size to container
    };
    return {trace : colorBarTrace, layout: colorBarLayout};
  };
  let updateViews = function(heatmapObject, colorBarObject){
    Plotly.newPlot(colorBarContainer, colorBarObject.trace, colorBarObject.layout, {responsive : true});
    Plotly.newPlot(heatmapContainer, heatmapObject.trace, heatmapObject.layout, {responsive : true});
  };
  heatmapObject = constructHeatmapData(groupStats, colorscale, margin, highlightGroupId);
  colorBarObject = constructColorBarData(colorscale, margin);
  updateViews(heatmapObject, colorBarObject);
  //var hoverTimer;  // Define a timer variable
  //var delay_hover = 0; // Delay in milliseconds
  heatmapContainer.on('plotly_click', data => updateUsingClickData(data, networkDrawingOptions, network));
}

/** Takes plotly click data and updates the network visualization highlight group accordingly.
 * 
 * @param {data} plotly click data 
 */
let updateUsingClickData = function(data, networkDrawingOptions, network){
  var xValue = data.points[0].x;
  resetGroupDrawingOptions(networkDrawingOptions, stylingVariables.defaultNodeColor) // autoreset at every hover
  highlightTargetGroup(networkDrawingOptions, xValue, stylingVariables.colorHighlight)
  network.setOptions(networkDrawingOptions);
  network.redraw();
}

/** Sets contrast key options in formSelectContrast
 * 
 * @param {*} optionsArrayContrastKeys 
 */
let setContrastKeys = function(optionsArrayContrastKeys){
  formSelectContrast.innerHTML = "";
  optionsArrayContrastKeys.forEach(function(optionKey) {
    let option = document.createElement("option");
    option.value = optionKey;
    option.text = optionKey;
    formSelectContrast.appendChild(option);
  });
  return undefined
}

/** Sets contrast key options in formSelectUnivMeasure
 * 
 * @param {*} optionsArrayContrastKeys 
 */
let setMeasureKeys = function(optionsArrayMeasureKeys){
  formSelectUnivMeasure.innerHTML = "";
  optionsArrayMeasureKeys.forEach(function(optionKey) {
    let option = document.createElement("option");
    option.value = optionKey;
    option.text = optionKey;
    formSelectUnivMeasure.appendChild(option);
  });
  return undefined
}

/** Function checks whether input json data contains expected keys.
 * 
 * @param {*} jsonData 
 * @returns {boolean} Indicating whether assertions were passed (true) or not (false)
 */
let assertInputSchemaValid = function (jsonData){
  // basic function to check whether the expected entries are available, to be replaced with object schema and type validation
  // jsonData is expected to be type object after a successful json parse. JSON parsing errors are handled separately.
  let schemaValid = true; 
  let expectedKeys = ["groupKeys", "groupMemberships", "univMeasureKeys", "groupMeasureKeys", "contrastKeys", "groupStats", "nodes", "edges"]
  for (key of expectedKeys){
    if (typeof(jsonData[key]) === "undefined"){
      schemaValid = false; 
      // The console log below is part of the desired console output
      console.log(`Key entry "${key}" not found in input data.`);
    }
  }
  if (schemaValid === false){
    alert(
      "Provided file does not contain expected input structues. See console log for missing entry." + 
      "Aborting file loading and interactive session initialization."
    );
  }
  return schemaValid
}

let parseInputAndInitalizeDashboard = function (fileInput) {
  let textLines = fileInput.target.result;
  let jsonData;
  let nodes, edges, groupKeys, groupStats, univMeasureKeys, contrastKeys;
  // Attempt Parsing of file input to json
  
  try {
    jsonData = JSON.parse(textLines);
  } catch (error) {
    alert(
      `Input data does not appear to conform with JSON file standard.` + 
      `Aborting data loading. Following error was generated: ${error}`
    );
    return undefined
  }
  // 
  if(!assertInputSchemaValid(jsonData)){return undefined;}
  nodes = jsonData["nodes"];
  edges = jsonData["edges"];
  groupKeys = jsonData["groupKeys"];
  groupMemberships = jsonData["groupMemberships"];
  groupStats = jsonData["groupStats"];
  univMeasureKeys = jsonData["univMeasureKeys"];
  contrastKeys = jsonData["contrastKeys"];
  //let groupMeasureKeys = jsonData["groupMeasureKeys"];
  
  setContrastKeys(contrastKeys);
  setMeasureKeys(univMeasureKeys);
  initializeInteractiveVisualComponents(nodes, edges, groupKeys, groupStats, contrastKeys, groupMemberships);
};

let assertFileReaderSupport = function (){
  let fileReaderSupported = true;
  if (typeof window.FileReader !== 'function') {
    alert("The file API isn't supported on this browser yet.");
    fileReaderSupported = false;
    return fileReaderSupported;
  } else {
    return fileReaderSupported;
  };
};

let assertFilePropertySupport = function (input){
  let filePropertySupported = true;
  if (input.files === "undefined") {
    alert("This browser does not seem to support the `files` property of file inputs.");
    filePropertySupported = false;
    return filePropertySupported;
  } else {
    return filePropertySupported;
  };
};

/** Reads and parses json data and calls dashboard initialization modules.
 * 
 */
let dataLoadingController = function() {
  let file, fileReader;
  let domElementFileInput = document.getElementById('id-file-input');
  if (!assertFileReaderSupport()){return;};
  if (!assertFilePropertySupport(domElementFileInput)){return;};
  if (domElementFileInput.files[0] === "undefined") {
    alert("Please select a file before clicking 'Load'"); 
    return;
  } else {
    file = domElementFileInput.files[0];
    fileReader = new FileReader();
    fileReader.addEventListener("load", parseInputAndInitalizeDashboard);
    fileReader.readAsText(file);
  };
};


// Bootstrap component nav tab change listener to force window-resize event upon chaning tabs
// this is needed for plotly.js and vis.js to properly size the visuals inside the tabs.
let navTabs = document.querySelector('.nav-pills');

// Add a listener function to the shown.bs.tab event
navTabs.addEventListener('shown.bs.tab', function (e) {
  // e.target is the new active tab
  // e.relatedTarget is the previous active tab
  // Trigger the window resize event
  window.dispatchEvent(new Event('resize'));
});


/** In place coordinates modification of network node coordinates using network physics.
 * 
 * @param {*} keyInput 
 * @param {*} network 
 * @param {*} networkEdgeData 
 * @param {*} fullEdgeData 
 */
let networkStabilizationController = function(keyInput, network, networkEdgeData, fullEdgeData){
  if (keyInput.key === 'Enter') {
    networkEdgeData.update(fullEdgeData);
    let n_iterations = Number(runNetworkPhysicsInput.value);
    network.stabilize(n_iterations);
    networkEdgeData.clear()
    network.storePositions();
    network.redraw()
    network.fit();
  }
  return undefined;
}
/** Function rescales x y coordinates to fit between [-1, +1] times scalingValue. Linear scaling.
 * 
 * @param {*} scalingValue A non-zero float
 * @param {*} nodes A list of node entries for vis network
 * @returns 
 */
let resizeLayout = function (scalingValue, networkNodeData){
  // nodeData: array of objects with x and y numeric data
  // function modified nodes object directly

  let updatedNodes = [];
  let allNodeIds = networkNodeData.getIds();
  
  // extract node information from networkNodeData (included up to date x and y coordinates)
  for (var i = 0; i < allNodeIds.length; i++) {
    updatedNodes.push(networkNodeData.get(allNodeIds[i]));
  };
  if (scalingValue > 0){
    const xValues = updatedNodes.map(obj => obj.x);
    const yValues = updatedNodes.map(obj => obj.y);

    const xMinValue = Math.min(...xValues);
    const xMaxValue = Math.max(...xValues);
    const yMinValue = Math.min(...yValues);
    const yMaxValue = Math.max(...yValues);

    if (xMinValue === xMaxValue){console.error("Error: xmin and xmax coordinates are identical!")};
    if (yMinValue === yMaxValue){console.error("Error: ymin and ymax coordinates are identical!")};

    const newMax = 1 * scalingValue;
    const newMin = -1 * scalingValue;
    const xScaleFactor = (newMax - newMin) / (xMaxValue - xMinValue);
    const ySaleFactor = (newMax - newMin) / (yMaxValue - yMinValue);
    // Assess current scale of x and y values
    // Set scale to unit scale and multiply with scalingValue
    for (let node of updatedNodes){
      node.x = (node.x - xMinValue) * xScaleFactor + newMin; 
      node.y = (node.y - yMinValue) * ySaleFactor + newMin;
    }
  }
  return updatedNodes;
}
/*
topKSelectionModule
*/
topKSelectionModule = (function(){
  const rangeInputTopKSelection = document.getElementById("id-topk-range-input");
  const topkLivePrintContainer = document.getElementById("id-topk-live-print");
  let updateTopKTextView = function(){
    topkLivePrintContainer.innerHTML = `Selected top-K value: ${this.value}`;
  };
  rangeInputTopKSelection.addEventListener("change", updateTopKTextView);

  let getTopKValue = function(){
    let value = rangeInputTopKSelection.value;
    return value
  };
  return {updateTopKTextView : updateTopKTextView, getTopKValue : getTopKValue};
})();






/**
  * Updates borderWidth of selected node to double size. For use inside vis.js network object.
  *
  * @param {values} object - visjs network selected return with styling elements accessible.
  */
const stylizeHighlightNode = function(values){
  values.borderWidth = values.borderWidth * 2;
};

/**
  * Updates borderWidth of selected node to double size. For use inside vis.js network object.
  *
  * @param {values} object - visjs network selected return with styling elements accessible.
  */
const stylizeHighlightEdge = function(values){
  values.color = stylingVariables.colorHighlight;
  values.opacity = 0.9;
};

/**
  * Initializes groupStyles object with default color setting each group in the network visualization.
  *
  * @param {array} groupsArray - Array of structure [{"group": "group_id1"}, {"group": "group_id2"}, ...]
  * @returns {object} groupStyles - Object with entries for each group_id containing defaultNodeColor styling.
  */
const generateDefaultGroupList = function (groupsArray, defaultColor){
  let groupStyles = {};
  for (groupEntry of groupsArray) {
    groupStyles[groupEntry] = {color: {background: defaultColor}}
  }
  return groupStyles;
}

/** Overwrites every group style entry to make use of color.
 * 
 * @param {*} drawingOptions 
 * @param {*} color 
 * @returns 
 */
const resetGroupDrawingOptions = function (drawingOptions, color) {
  for (let [key, value] of Object.entries(drawingOptions["groups"])) {
    drawingOptions["groups"][key]["color"]["background"] = color;
  }
  return undefined // ... drawingOptions modified in place, no return value.
}

/** Generates default network drawing options.
 * 
 * @param {*} groupList 
 * @returns 
 */
const generateNetworkDrawingOptions = function(groupList){
  // This structure contains any styling used for the network.
  // This structure is modified to recolor groups if a node belonging to the group is selected.
  // Here, the groups color attribute is changed. 
  // On data load, add this group-information such that all groups are set to default node color.
  // When a node is clicked, node group can be accessed to change color and redraw.
  // It is not possible to override the default coloring of groups any other way than specifying a replacement 
  // color here. Any other solution would involve direct node modification (change color of each specific node).
  let networkDrawingOptions;
  networkDrawingOptions = {
    groups: groupList,
    physics: false,
    nodes: {
      shape: "dot", // use dot, circle scales to the label size as the label is inside the shape! 
      chosen: {node: stylizeHighlightNode}, // this passes the function to style the respective selected node
      color: {background: stylingVariables.defaultNodeColor, border: stylingVariables.defaultNodeBorderColor},
      size: 25, font: {size: 14, face: "Helvetica"}, borderWidth: 1, 
    },
    edges: {
      chosen: {edge:stylizeHighlightEdge}, // this passes the function to style the respective selected edge
      font:  {size: 14, face: "Helvetica"},
      color: { opacity: 0.6, color: stylingVariables.defaultEdgeColor, inherit: false},
      smooth: {type: "straightCross", forceDirection: "none", roundness: 0.25},
    },
    interaction: {
      selectConnectedEdges: true, // prevent edge highlighting upon node selection
      hover:true, hideEdgesOnDrag: false, tooltipDelay: 100
    },

  };
  return networkDrawingOptions;
};

/** Overwrites target group style entry to make use of color.
 * 
 * @param {*} drawingOptions 
 * @param {*} group 
 * @param {*} color 
 * @returns 
 */
let highlightTargetGroup = function (drawingOptions, group, color){
  drawingOptions["groups"][group]["color"]["background"] = color;
  return undefined // ... drawingOptions modified in place, no return value.
}
/** Function filters edge list down to 
 * 
 * @param {*} edgeList 
 * @param {*} nodeId 
 * @returns 
 */
const filterEdges = function(edgeList, nodeId){
  let filteredEdgeSet = new Set([]);
  if (edgeList.length > 0){
    for (let i = 0; i < edgeList.length; i++) {
      if (edgeList[i].from == nodeId || edgeList[i].to == nodeId ){
        filteredEdgeSet.add(edgeList[i])
      };
    };
    let allEdgesForNode = Array.from(filteredEdgeSet);
    allEdgesForNode.sort((a,b) => a.data.score - b.data.score).reverse();
    let topK = topKSelectionModule.getTopKValue();
    let nElemetsToSelect = Math.min(allEdgesForNode.length, topK);
    topKEdgesForNode = allEdgesForNode.slice(0, nElemetsToSelect);
    return topKEdgesForNode;
  };
  return Array.from(filteredEdgeSet)
};

/**
 * 
 * @param {*} inputNodeData 
 * @param {*} selectedNodeId 
 * @returns 
 */
const getNodeDataInfo = function (inputNodeData, selectedNodeId, contrastKeys){
  // function expects selectedNode["data"] information
  let outputString = 'Data for clicked node with id: ' + String(selectedNodeId) + "\n";
  //console.log("Checking nodeData", inputNodeData)
  if ("spectrum_ms_information" in inputNodeData){
    outputString += 'Spectrum information:\n'
    outputString += `  precursor_mz: ${inputNodeData["spectrum_ms_information"]["precursor_mz"]}\n`
    outputString += `  retention_time: ${inputNodeData["spectrum_ms_information"]["retention_time"]}\n`
  }
  outputString += 'Univariate data:\n'
  for (const contrastKey of contrastKeys) {
    outputString += `[${contrastKey}:]\n`
    for (const measureKey in inputNodeData[contrastKey]){
      if (["univariatePValue", "log2FoldChange"].includes(measureKey)){
        // only these two measures have a measure and nodeSize difference in their data.
        value = inputNodeData[contrastKey][measureKey]["measure"];
      } else {
        value = inputNodeData[contrastKey][measureKey];
      }
      outputString += `  ${measureKey}: ${value}\n`
    }
  }
  return outputString
};

/**
 * Extracts node label for specific node from network.
 *
 * @param {network} array - Array of structure [{"group": "group_id1"}, {"group": "group_id2"}, ...]
 * @param {network} array - Array of structure [{"group": "group_id1"}, {"group": "group_id2"}, ...]
 * @returns {string} output - Object with entries for each group_id containing defaultNodeColor styling.
**/
function getNodeGroup(network, nodeId){
  // custom function to access network data
  var nodeObj= network.body.data.nodes._data[nodeId];
  return nodeObj.group;
}

/**
 * 
 * @param {*} inputGroupData 
 * @param {*} groupId 
 * @returns 
 */
let getNodeGroupInfo = function (inputGroupData, groupId){
  // function expected selectedGroup["data"] information
  let outputString = 'Group-based data for feature-set with id =  ' + String(groupId) + "\n";
  console.log("Checking groupData", inputGroupData)
  for (const contrastKey in inputGroupData) {
    outputString += `[${contrastKey}:]\n`
    for (const measureKey in inputGroupData[contrastKey]){
      rounded_value = inputGroupData[contrastKey][measureKey].toFixed(4)
      outputString += `  ${measureKey}: ${rounded_value}\n`
    }
  }
  return outputString
}


/**
 * 
 * @param {*} groupMemberships group_id keyed object with feature_ids for each member
 * @param {*} groupId 
 * @returns string with feature_ids styles to add no more than 5 ids per line of text.
 */
let getGroupmemberships = function (groupMemberships, groupId){
  let outputString = 'Features belonging to group with id =  ' + String(groupId) + ":\n";
  let counter = 1;
  for (const feature_id of groupMemberships[groupId]) {
    if (counter % 10 == 0){
      outputString += "\n";
    }
    outputString += String(feature_id) + ", ";
    counter += 1;
  }
  outputString += "\n";
  return outputString
}

/** Gets label data for node with specified id.
 * 
 * @param {vis.network} network 
 * @param {string} nodeId 
 * @returns 
 */
function getNodeLabel(network, nodeId){
  // custom function to access network data
  var nodeObj= network.body.data.nodes._data[nodeId];
  let output = nodeObj.label;
  return output;
};
/** Function handles network drag event.
 * 
 * @param {*} dragNodeData 
 * @param {*} network 
 */
let networkDragController = function(dragNodeData, network){
  network.storePositions(); 
}

/** Function handles network click response
 * 
 * @param {*} clickInput 
 * @param {*} network 
 * @param {*} networkNodeData 
 * @param {*} networkEdgeData 
 * @param {*} edges 
 * @param {*} groupStats
 * @param {*} networkDrawingOptions
 */
let networkClickController = function(clickInput, network, networkNodeData, networkEdgeData, edges, groupStats, networkDrawingOptions, contrastKeys, groupMemberships) {
  // If a node is clicked, addon visualization is added,
  // If an empty area is clicked, edge and styling data is reset
  if (clickInput.nodes.length > 0){
    let selectedNode = clickInput.nodes[0]; // assumes only single selections possible!
    let edgeSubset = filterEdges(edges, selectedNode);
    let nodeGroup = getNodeGroup(network, selectedNode);
    let infoString;
    let clickedNode
    networkEdgeData.update(edgeSubset);
    infoGroupLevel = getNodeGroupInfo(groupStats[nodeGroup], nodeGroup);
    infoGroupMembers = getGroupmemberships(groupMemberships, nodeGroup);
    resetGroupDrawingOptions(networkDrawingOptions, stylingVariables.defaultNodeColor);
    highlightTargetGroup(networkDrawingOptions, nodeGroup, stylingVariables.colorHighlight);
    network.storePositions();
    clickedNode = networkNodeData.get(selectedNode);
    infoString = getNodeDataInfo(clickedNode["data"], selectedNode, contrastKeys);
    nodeInfoContainer.innerText = infoString + infoGroupLevel + infoGroupMembers;
    network.setOptions(networkDrawingOptions);
    network.redraw();
    heatmapPanelController(groupStats, formSelectContrast, networkDrawingOptions, network, highlightGroupId = nodeGroup); // <-- this
  } else {
    nodeInfoContainer.innerText = "";
    network.storePositions();
    networkEdgeData.clear();
    resetGroupDrawingOptions(networkDrawingOptions, stylingVariables.defaultNodeColor);
    network.setOptions(networkDrawingOptions);
    network.redraw();
    heatmapPanelController(groupStats, formSelectContrast, networkDrawingOptions, network); // <-- this
  }
};

/** Function updates the network data for visualization
 * 
 * @param {*} networkNodeData 
 * @param {*} selectedContrast 
 * @param {*} selectedMeasure 
 * @returns 
 */
let updateNetworkNodeData = function(networkNodeData, selectedContrast, selectedMeasure) {
  let updatedNodes = [];
  let allNodeIds = networkNodeData.getIds();
  for (var i = 0; i < allNodeIds.length; i++) {
    // For each node, replace the size with the size from the contrast measure selection
    var nodeToUpdate = networkNodeData.get(allNodeIds[i]);
    nodeToUpdate["size"] = nodeToUpdate["data"][selectedContrast][selectedMeasure]["nodeSize"];
    updatedNodes.push(nodeToUpdate);
  };
  networkNodeData.update(updatedNodes);
  return networkNodeData;
};

/** Function handles change in measure or contrast selections
 * 
 * @param {*} networkNodeData 
 * @param {*} network
 * @returns
 */
let updateNodeDataToContrastAndMeasure = function(networkNodeData, network){
  let selectedContrast = formSelectContrast.value;
  let selectedMeasure = formSelectUnivMeasure.value;
  updateNetworkNodeData(networkNodeData, selectedContrast, selectedMeasure); // in place modification
  network.redraw();
  return undefined
}

/** Function resizes network upon window resizing (updates both model and view)
*/
eventHandlerWindowResize = function(network){
  network.fit();
};

/** Function controls response to keydown event on coordinate scaling input. 
 * 
 * @param {*} keydown 
 * @param {*} nodes 
 * @param {*} networkNodeData 
 * @param {*} network 
 */
let eventHandlerCoordinateScaling = function (keydown, networkNodeData, network, scalingInput){
  // Function only rescales upon enter click
  if (keydown.key === 'Enter') {
    updatedNodes = resizeLayout(scalingInput.value, networkNodeData); // updates the node data
    networkNodeData.clear();
    networkNodeData.update(updatedNodes);
    //updateNodeDataToContrastAndMeasure(networkNodeData, network);
    network.fit();
  };
};

function initializeInteractiveVisualComponents(nodes, edges, groups, groupStats, contrastKeys, groupMemberships){
  let networkDrawingOptions;
  let groupList;
  let fullEdgeData; // used for force directed layout only
  let networkNodeData;
  let networkEdgeData;
  let networkData; 
  let network;
  
  groupList = generateDefaultGroupList(groups, stylingVariables.defaultNodeColor);
  networkDrawingOptions = generateNetworkDrawingOptions(groupList);
  // Add node title information based on node id and node group:
  
  nodes.forEach(function(node) {
    node.title = 'ID: ' + node.id + '<br>Group: ' + node.group;
  });

  // Processing Edges; rounding labels to make sure they are printable on edges
  for (let edge of edges){
    edge["label"] = `${edge["data"]["score"].toFixed(2)}`;
  };
  edges.forEach(function(edge) {
    edge.title = 'ID: ' + edge.id + '<br>Score: ' + edge.data.score;
  });

  fullEdgeData = new vis.DataSet(edges);
  networkNodeData = new vis.DataSet(nodes);
  networkEdgeData = new vis.DataSet([]);

  // construct network variable and attach to div
  networkData = {nodes: networkNodeData, edges: networkEdgeData};
  network = new vis.Network(networkContainer, networkData, networkDrawingOptions);

  // Initialize Visual Interaction Event Controllers
  heatmapPanelController(groupStats, formSelectContrast, networkDrawingOptions, network);
  // Init Run NodeChangeData handler to ensure match between selected options and display data
  updateNodeDataToContrastAndMeasure(networkNodeData, network);

  network.on("dragging", (dragNodeData) => networkDragController(dragNodeData, network));

  network.on("click", input => networkClickController(
    input, network, networkNodeData, networkEdgeData, edges, groupStats, networkDrawingOptions, contrastKeys, groupMemberships
    )
  );

  runNetworkPhysicsInput.addEventListener('keydown', 
    keyInput => networkStabilizationController(
      keyInput, network, networkEdgeData, fullEdgeData
    )
  );

  formSelectContrast.addEventListener(
    "change",
    () => updateNodeDataToContrastAndMeasure(networkNodeData, network)
  );

  formSelectUnivMeasure.addEventListener(
    "change", 
    () => updateNodeDataToContrastAndMeasure(networkNodeData, network)
  );

  scalingInput.addEventListener(
    'keydown', 
    (keydown) => eventHandlerCoordinateScaling(keydown, networkNodeData, network, scalingInput)
  );
  window.onresize = eventHandlerWindowResize(network)
};

buttonLoadJsonData.addEventListener("click", dataLoadingController);





  </script>
 </body>
</html>